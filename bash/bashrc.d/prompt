#!/usr/bin/env bash

# --- Colors (Bash-safe: wrapped in \[ \] so readline counts width correctly) ---
RESET="\[\e[0m\]"
BOLD="\[\e[1m\]"
DIM="\[\e[2m\]"

FG_RED="\[\e[31m\]"
FG_GREEN="\[\e[32m\]"
FG_YELLOW="\[\e[33m\]"
FG_BLUE="\[\e[34m\]"
FG_MAGENTA="\[\e[35m\]"
FG_CYAN="\[\e[36m\]"
FG_WHITE="\[\e[37m\]"

# --- Glyphs (set PROMPT_GLYPHS=ascii if your font/terminal is limited) ---
: "${PROMPT_GLYPHS:=unicode}"
if [[ "$PROMPT_GLYPHS" == "ascii" ]]; then
  GLY_OK="ok"
  GLY_FAIL="!!"
  GLY_BRANCH="git:"
  GLY_DIRTY="*"
  GLY_PROMPT=">"
else
  GLY_OK="✔"
  GLY_FAIL="✘"
  GLY_BRANCH=""   # may show as a box if your font lacks it; switch to ascii if so
  GLY_DIRTY="●"
  GLY_PROMPT="❯"
fi

# --- Git info (branch + dirty marker), quiet when not in a repo ---
__prompt_git() {
  command -v git >/dev/null 2>&1 || return 0
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 0

  local branch dirty=""
  branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null \
        || git rev-parse --short HEAD 2>/dev/null)" || return 0

  # Dirty if staged/unstaged/untracked changes exist
  git diff --quiet --ignore-submodules -- 2>/dev/null || dirty="$GLY_DIRTY"
  git diff --cached --quiet --ignore-submodules -- 2>/dev/null || dirty="$GLY_DIRTY"
  [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null | head -n 1)" ]] && dirty="$GLY_DIRTY"

  # output includes leading space so it can be appended cleanly
  printf " %s %s%s" "$GLY_BRANCH" "$branch" "$dirty"
}

# --- Python venv (optional) ---
__prompt_venv() {
  [[ -n "$VIRTUAL_ENV" ]] || return 0
  printf " (%s)" "${VIRTUAL_ENV##*/}"
}

# --- Detect SSH session ---
__is_ssh() {
  [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" || -n "$SSH_CONNECTION" ]]
}

# --- Prompt builder (runs before each prompt) ---
__prompt_command() {
  local last_status=$?

  # Agent mode: keep it intentionally minimal
  if [[ "$ANTIGRAVITY_AGENT" == "1" ]]; then
    PS1="$ "
    return
  fi

  local user_host cwd git venv ssh_indicator status_symbol status_color prompt_char
  cwd="\W"
  git="$(__prompt_git)"
  venv="$(__prompt_venv)"

  if __is_ssh; then
    ssh_indicator="󰛳 ssh "
  else
    ssh_indicator=""
  fi

  # Status indicator
  if (( last_status == 0 )); then
    status_symbol="$GLY_OK"
    status_color="$FG_GREEN"
  else
    status_symbol="$GLY_FAIL $last_status"
    status_color="$FG_RED"
  fi

  # Prompt character: root vs user
  if [[ $EUID -eq 0 ]]; then
    prompt_char="#"
  else
    prompt_char="$GLY_PROMPT"
  fi

  # Termux: shorter, still pretty
  if [[ -n "$TERMUX_VERSION" ]]; then
    PS1="${DIM}${ssh_indicator}${status_color}${status_symbol}${RESET}${DIM} ${FG_BLUE}${cwd}${RESET}${FG_YELLOW}${git}${RESET}${FG_MAGENTA}${venv}${RESET}\n${status_color}${prompt_char}${RESET} "
    return
  fi

  # Normal: two-line prompt (readable + “beautiful”)
  # Line 1: status + user@host + cwd + git + venv
  # Line 2: prompt symbol
  PS1="${DIM}${ssh_indicator}${status_color}${status_symbol}${RESET}${DIM} ${FG_GREEN}\u@\h${RESET} ${FG_BLUE}${cwd}${RESET}${FG_YELLOW}${git}${RESET}${FG_MAGENTA}${venv}${RESET}\n${status_color}${prompt_char}${RESET} "
}

# Hook into Bash prompt rendering
PROMPT_COMMAND=__prompt_command
