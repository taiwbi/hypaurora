#!/usr/bin/env bash

# --- Colors (Bash-safe: wrapped in \[ \] so readline counts width correctly) ---
RESET="\[\e[0m\]"
BOLD="\[\e[1m\]"
DIM="\[\e[2m\]"

FG_RED="\[\e[31m\]"
FG_GREEN="\[\e[32m\]"
FG_YELLOW="\[\e[33m\]"
FG_BLUE="\[\e[34m\]"
FG_MAGENTA="\[\e[35m\]"
FG_CYAN="\[\e[36m\]"
FG_WHITE="\[\e[37m\]"

# --- Glyphs (set PROMPT_GLYPHS=ascii if your font/terminal is limited) ---
: "${PROMPT_GLYPHS:=unicode}"
if [[ "$PROMPT_GLYPHS" == "ascii" ]]; then
  GLY_OK="ok"
  GLY_FAIL="!!"
  GLY_BRANCH="git:"
  GLY_DIRTY="*"
  GLY_PROMPT=">"
else
  GLY_OK="✔"
  GLY_FAIL="✘"
  GLY_BRANCH=""   # may show as a box if your font lacks it; switch to ascii if so
  GLY_DIRTY="●"
  GLY_PROMPT="❯"
fi

# --- Git info (branch + dirty marker), quiet when not in a repo ---
__prompt_git() {
  command -v git >/dev/null 2>&1 || return 0
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 || return 0

  local branch dirty=""
  branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null \
        || git rev-parse --short HEAD 2>/dev/null)" || return 0

  # Dirty if staged/unstaged/untracked changes exist
  git diff --quiet --ignore-submodules -- 2>/dev/null || dirty="$GLY_DIRTY"
  git diff --cached --quiet --ignore-submodules -- 2>/dev/null || dirty="$GLY_DIRTY"
  [[ -n "$(git ls-files --others --exclude-standard 2>/dev/null | head -n 1)" ]] && dirty="$GLY_DIRTY"

  # output includes leading space so it can be appended cleanly
  printf " %s %s%s" "$GLY_BRANCH" "$branch" "$dirty"
}

# --- Python venv (optional) ---
__prompt_venv() {
  [[ -n "$VIRTUAL_ENV" ]] || return 0
  printf " (%s)" "${VIRTUAL_ENV##*/}"
}

# --- PWD formatting ---
__prompt_pwd() {
    # prints the path according to $bash_prompt_pwd_dir_length
    # - 0 => full absolute path (no ~ substitution)
    # - n > 0 => substitute $HOME with ~ and shorten each directory
    #            component (except the last) to n chars

    local dirlen="$bash_prompt_pwd_dir_length"
    local pwd path prefix parts joined comp i last out=()

    # validate dirlen is a non-negative integer, fallback to 1
    if ! [[ "$dirlen" =~ ^[0-9]+$ ]]; then
        dirlen=1
    fi

    # get physical path (resolving symlinks)
    pwd="$(pwd -P)"

    # if dirlen == 0 -> show absolute path (no ~ replacement)
    if [ "$dirlen" -eq 0 ]; then
        printf '%s' "$pwd"
        return
    fi

    # Determine prefix and the path to split:
    # - If in $HOME -> prefix '~' and path = rest after $HOME
    if [ "${pwd#$HOME}" != "$pwd" ]; then
        prefix='~'
        path="${pwd#$HOME}"
        path="${path#/}"   # remove leading slash after ~
    elif [ "${pwd#/}" != "$pwd" ]; then
        prefix='/'
        path="${pwd#/}"
    else
        prefix=''
        path="$pwd"
    fi

    # split into components
    IFS='/' read -ra parts <<< "$path"
    last=$(( ${#parts[@]} - 1 ))

    for i in "${!parts[@]}"; do
        comp="${parts[i]}"
        # keep empty components (rare here) as empty string
        if [ -z "$comp" ]; then
            out+=( "" )
            continue
        fi

        if [ "$i" -eq "$last" ]; then
            # last component: show full name
            out+=( "$comp" )
        else
            # intermediate components: shorten if longer than dirlen
            if [ "${#comp}" -le "$dirlen" ]; then
                out+=( "$comp" )
            else
                out+=( "${comp:0:dirlen}" )
            fi
        fi
    done

    # join with '/'
    joined="$(IFS=/; echo "${out[*]}")"

    # print with correct prefix
    if [ "$prefix" = "/" ]; then
        # absolute path not in $HOME
        printf '/%s' "$joined"
    elif [ "$prefix" = "~" ]; then
        if [ -n "$joined" ]; then
            printf '~/%s' "$joined"
        else
            printf '~'
        fi
    else
        printf '%s' "$joined"
    fi
}

# --- Detect SSH session ---
__is_ssh() {
  [[ -n "$SSH_CLIENT" || -n "$SSH_TTY" || -n "$SSH_CONNECTION" ]]
}

# --- Prompt builder (runs before each prompt) ---
__prompt_command() {
  local last_status=$?

  # Agent mode: keep it intentionally minimal
  if [[ "$ANTIGRAVITY_AGENT" == "1" ]]; then
    PS1="$ "
    return
  fi

  local user_host cwd git venv ssh_indicator status_symbol status_color prompt_char
  cwd="$(__prompt_pwd)"
  git="$(__prompt_git)"
  venv="$(__prompt_venv)"

  if __is_ssh; then
    ssh_indicator="󰛳 ssh "
  else
    ssh_indicator=""
  fi

  # Status indicator
  if (( last_status == 0 )); then
    status_symbol="$GLY_OK"
    status_color="$FG_GREEN"
  else
    status_symbol="$GLY_FAIL $last_status"
    status_color="$FG_RED"
  fi

  # Prompt character: root vs user
  if [[ $EUID -eq 0 ]]; then
    prompt_char="#"
  else
    prompt_char="$GLY_PROMPT"
  fi

  # Line 1: status + user@host + cwd + git + venv
  # Line 2: prompt symbol
  PS1="${DIM}${ssh_indicator}${status_color}${status_symbol}${RESET}${DIM} ${FG_GREEN}\u@\h${RESET} ${FG_BLUE}${cwd}${RESET}${FG_YELLOW}${git}${RESET}${FG_MAGENTA}${venv}${RESET}\n${status_color}${prompt_char}${RESET} "
}

# Hook into Bash prompt rendering
PROMPT_COMMAND=__prompt_command
