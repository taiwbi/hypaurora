#!/usr/bin/env bash
set -euo pipefail

# Configuration
readonly OUTPUT_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/lockscreen"
readonly TARGET_WIDTH=1920
readonly TARGET_HEIGHT=1080

# Color codes for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info()  { echo -e "${GREEN}[INFO]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*" >&2; }
log_warn()  { echo -e "${YELLOW}[WARN]${NC} $*"; }

# Desktop notification
notify_user() {
    local title="$1"
    local message="$2"
    command -v notify-send &>/dev/null && notify-send "$title" "$message"
}

# Check dependencies
check_dependencies() {
    local missing=()
    for cmd in ffmpeg ffprobe; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required dependencies: ${missing[*]}"
        log_error "Install with: sudo apt install ffmpeg"
        exit 1
    fi
}

# Validate input file (image/video)
validate_image() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        log_error "File does not exist: $file"
        return 1
    fi
    # ffprobe to check if there's a video/image stream
    if ! ffprobe -v error -select_streams v:0 -show_entries stream=codec_type \
        -of default=noprint_wrappers=1:nokey=1 "$file" &>/dev/null; then
        log_error "Not a valid image/video file: $file"
        return 1
    fi
    return 0
}

# Process image using ffmpeg -> write temporary .png then move to extensionless destination
process_image() {
    local input="$1"
    local dest_noext="$2"

    log_info "Processing image: $(basename "$input")"

    local dest_dir
    dest_dir="$(dirname "$dest_noext")"
    mkdir -p "$dest_dir"

    # Create a temporary PNG in the same directory (atomic move on same FS)
    local tmp_png
    tmp_png="$(mktemp "${dest_dir}/.tmp_lock_XXXXXX.png")" || {
        log_error "Could not create temporary file in ${dest_dir}"
        return 1
    }

    # Ensure tmp file removed on failure/exit
    cleanup() {
        local rc=$?
        [[ -f "$tmp_png" ]] && rm -f "$tmp_png" || true
        return $rc
    }
    trap 'cleanup' EXIT

    # scale-to-cover then center-crop to exact target
    if ffmpeg -y -loglevel error \
        -i "$input" \
        -vf "scale=w='max(${TARGET_WIDTH},iw*max(${TARGET_WIDTH}/iw,${TARGET_HEIGHT}/ih))':h='max(${TARGET_HEIGHT},ih*max(${TARGET_WIDTH}/iw,${TARGET_HEIGHT}/ih))',crop=${TARGET_WIDTH}:${TARGET_HEIGHT}" \
        -pix_fmt rgb24 \
        -compression_level 6 \
        "$tmp_png"; then

        if mv -f "$tmp_png" "$dest_noext"; then
            # successful, disable cleanup trap (tmp moved)
            trap - EXIT
            log_info "Lockscreen image saved to: $dest_noext"
            return 0
        else
            log_error "Failed to move temporary PNG to destination"
            return 1
        fi
    else
        log_error "ffmpeg failed to process the image"
        return 1
    fi
}

main() {
    if [[ $# -eq 0 ]]; then
        log_error "No file provided. Usage: $0 <image_file>"
        exit 1
    fi

    local input_file="$1"

    check_dependencies

    if ! validate_image "$input_file"; then
        exit 1
    fi

    if ! process_image "$input_file" "$OUTPUT_FILE"; then
        exit 1
    fi

    log_info "LockScreen updated successfully!"
    notify_user "Lockscreen Updated" "Lockscreen image has been changed."
}

main "$@"
