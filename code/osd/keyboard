#!/usr/bin/env bash

# Event-driven keyboard layout OSD script for niri + eww

OSD_WINDOW="keyboard_osd"
TIMEOUT=2
LOCK_FILE="/tmp/eww_keyboard_osd.lock"
PID_FILE="/tmp/eww_keyboard_osd.pid"

# Function to show OSD
show_osd() {
    if ! eww active-windows | grep -q "^${OSD_WINDOW}:"; then
        eww open "$OSD_WINDOW"
    fi
}

# Function to hide OSD
hide_osd() {
    eww close "$OSD_WINDOW" 2>/dev/null
}

# Function to start hide timer
start_hide_timer() {
    # Kill any existing timer process
    if [ -f "$PID_FILE" ]; then
        local old_pid=$(cat "$PID_FILE")
        if kill -0 "$old_pid" 2>/dev/null; then
            kill "$old_pid" 2>/dev/null
        fi
    fi
    
    # Update timestamp for when OSD should hide
    local hide_time=$(($(date +%s) + TIMEOUT))
    echo "$hide_time" > "/tmp/eww_keyboard_osd_hide_time.state"
    
    # Start new timer in background
    (
        while true; do
            sleep 0.1
            local current_time=$(date +%s)
            local target_time=$(cat "/tmp/eww_keyboard_osd_hide_time.state" 2>/dev/null || echo "0")
            
            if [ "$current_time" -ge "$target_time" ]; then
                # Check if we still own the lock
                if [ -f "$LOCK_FILE" ] && [ $$ = "$(cat "$LOCK_FILE")" ]; then
                    hide_osd
                    rm -f "$LOCK_FILE" "$PID_FILE" "/tmp/eww_keyboard_osd_hide_time.state"
                fi
                break
            fi
        done
    ) &
    
    # Store the timer PID
    echo $! > "$PID_FILE"
}

# Function to acquire lock
acquire_lock() {
    # Check if lock exists and if the process is still running
    if [ -f "$LOCK_FILE" ]; then
        local lock_pid=$(cat "$LOCK_FILE")
        if kill -0 "$lock_pid" 2>/dev/null; then
            # Another instance is running, just extend its timer
            return 1
        else
            # Stale lock file, remove it
            rm -f "$LOCK_FILE" "$PID_FILE"
        fi
    fi
    
    # Acquire the lock
    echo $$ > "$LOCK_FILE"
    return 0
}

# Function to cleanup
cleanup() {
    if [ -f "$LOCK_FILE" ] && [ $$ = "$(cat "$LOCK_FILE")" ]; then
        hide_osd
        rm -f "$LOCK_FILE" "$PID_FILE" "/tmp/eww_keyboard_osd_hide_time.state"
    fi
}

# Set up cleanup trap
trap cleanup EXIT

# Try to acquire lock for OSD management
if acquire_lock; then
    # We own the lock, manage the OSD
    niri msg action switch-layout "next"
    show_osd
    start_hide_timer
    
    # Wait for the timer process to complete
    if [ -f "$PID_FILE" ]; then
        wait $(cat "$PID_FILE") 2>/dev/null
    fi
else
    # Another instance is managing the OSD, just update state and extend timer
    niri msg action switch-layout "next"
    # Update the hide timestamp to extend the display time
    hide_time=$(($(date +%s) + TIMEOUT))
    echo "$hide_time" > "/tmp/eww_keyboard_osd_hide_time.state"
fi
