#!/usr/bin/env bash

# OSD Configuration (matching volume script)
OSD_WINDOW="touchpad_osd"
TIMEOUT=2
TOUCHPAD_STATE_FILE="/tmp/eww_osd_touchpad.state"
LOCK_FILE="/tmp/eww_osd.lock"
PID_FILE="/tmp/eww_osd.pid"

# Niri configuration
CONFIG_FILE="$HOME/.config/niri/config.kdl"

# Function to show OSD
show_osd() {
    if ! eww active-windows | grep -q "^${OSD_WINDOW}:"; then
        eww open "$OSD_WINDOW"
    fi
}

# Function to hide OSD
hide_osd() {
    eww close "$OSD_WINDOW" 2>/dev/null
}

# Function to get current touchpad state
get_touchpad_state() {
    if grep -A 1 "touchpad {" "$CONFIG_FILE" | grep -q "off"; then
        echo "disabled"
    else
        echo "enabled"
    fi
}

# Function to update state file
update_state() {
    local state=$(get_touchpad_state)
    echo "$state" > "$TOUCHPAD_STATE_FILE"
}

# Function to start hide timer
start_hide_timer() {
    # Kill any existing timer process
    if [ -f "$PID_FILE" ]; then
        local old_pid=$(cat "$PID_FILE")
        if kill -0 "$old_pid" 2>/dev/null; then
            kill "$old_pid" 2>/dev/null
        fi
    fi
    
    # Update timestamp for when OSD should hide
    local hide_time=$(($(date +%s) + TIMEOUT))
    echo "$hide_time" > "/tmp/eww_osd_hide_time.state"
    
    # Start new timer in background
    (
        while true; do
            sleep 0.1
            local current_time=$(date +%s)
            local target_time=$(cat "/tmp/eww_osd_hide_time.state" 2>/dev/null || echo "0")
            
            if [ "$current_time" -ge "$target_time" ]; then
                # Check if we still own the lock
                if [ -f "$LOCK_FILE" ] && [ $$ = "$(cat "$LOCK_FILE")" ]; then
                    hide_osd
                    rm -f "$LOCK_FILE" "$PID_FILE" "/tmp/eww_osd_hide_time.state"
                fi
                break
            fi
        done
    ) &
    
    # Store the timer PID
    echo $! > "$PID_FILE"
}

# Function to acquire lock
acquire_lock() {
    # Check if lock exists and if the process is still running
    if [ -f "$LOCK_FILE" ]; then
        local lock_pid=$(cat "$LOCK_FILE")
        if kill -0 "$lock_pid" 2>/dev/null; then
            # Another instance is running, just extend its timer
            return 1
        else
            # Stale lock file, remove it
            rm -f "$LOCK_FILE" "$PID_FILE"
        fi
    fi
    
    # Acquire the lock
    echo $$ > "$LOCK_FILE"
    return 0
}

# Function to cleanup
cleanup() {
    if [ -f "$LOCK_FILE" ] && [ $$ = "$(cat "$LOCK_FILE")" ]; then
        hide_osd
        rm -f "$LOCK_FILE" "$PID_FILE" "/tmp/eww_osd_hide_time.state"
    fi
}

# Function to toggle touchpad
toggle_touchpad() {
    # Check if config file exists
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "Error: Configuration file $CONFIG_FILE not found."
        exit 1
    fi

    # Check if touchpad section exists, create it if it doesn't
    if ! grep -q "input {" "$CONFIG_FILE"; then
        echo -e "input {\n    touchpad {\n    }\n}" >> "$CONFIG_FILE"
    elif ! grep -q "touchpad {" "$CONFIG_FILE"; then
        # Add touchpad section inside input
        sed -i '/input {/a\    touchpad {\n    }' "$CONFIG_FILE"
    fi

    # Create temp file for modifications
    local TEMP_FILE=$(mktemp)

    # Check if 'off' keyword is present in touchpad section
    if grep -A 1 "touchpad {" "$CONFIG_FILE" | grep -q "off"; then
        # Remove 'off' to enable touchpad
        sed '/touchpad {/,/}/ {/^\s*off\s*$/d}' "$CONFIG_FILE" > "$TEMP_FILE"
        mv "$TEMP_FILE" "$CONFIG_FILE"
        echo "Touchpad enabled."
    else
        # Add 'off' to disable touchpad
        sed '/touchpad {/a\        off' "$CONFIG_FILE" > "$TEMP_FILE"
        mv "$TEMP_FILE" "$CONFIG_FILE"
        echo "Touchpad disabled."
    fi
}

# Set up cleanup trap
trap cleanup EXIT

# Perform touchpad toggle
toggle_touchpad

# Try to acquire lock for OSD management
if acquire_lock; then
    # We own the lock, manage the OSD
    show_osd
    update_state
    start_hide_timer
    
    # Wait for the timer process to complete
    if [ -f "$PID_FILE" ]; then
        wait $(cat "$PID_FILE") 2>/dev/null
    fi
else
    # Another instance is managing the OSD, just update state and extend timer
    update_state
    # Update the hide timestamp to extend the display time
    hide_time=$(($(date +%s) + TIMEOUT))
    echo "$hide_time" > "/tmp/eww_osd_hide_time.state"
fi
